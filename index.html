<!DOCTYPE html>
<html>
<head>
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z0545N293J"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-Z0545N293J');
    </script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8987947512818621"
     crossorigin="anonymous"></script>
    <title>Neon Runner Deluxe</title>
   <style>
        body {
            margin: 0;
            background: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            border: 2px solid #333;
            box-shadow: 0 0 20px #0ff;
            background: #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="450"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIG ---
const INITIAL_SPEED = 6;
let currentBaseSpeed = INITIAL_SPEED; 
let GAME_SPEED = 6;
let GRAVITY = 0.6;
const BASE_GRAVITY = 0.6;
const JUMP_FORCE = -11;

// --- STATE ---
let isStarted = false; 
let frame = 0;
let score = 0;
let difficultyLevel = 0;
let isGameOver = false;
let isPaused = false;
let activeHazards = []; 
let hazardMaxTime = 0;
let timeSinceHazard = 0;
let messageTimer = 0; 
let menuDrawn = false; 

// --- INPUT ---
const keys = {
    Space: false, KeyZ: false, KeyX: false, KeyC: false, KeyV: false,
    KeyR: false, KeyT: false, KeyG: false
};

// --- SKILLS ---
const skills = {
    doubleJump: 0, dash: 0, float: 0, dive: 0, shield: false, slowTime: 0,
    teleport: 0,   // 0: Locked, 1: Single TP, 2: Double TP
    shrink: 0,     // 0: Locked, 1: Normal Shrink, 2: Greater Shrink
    gravitySwap: 0 // 0: Locked, 1: Unlock, 2: Short CD
};

// --- RUNTIME VARS ---
let canDash = true;
let dashTimer = 0;
let floatTimer = 0;
let slowTimer = 0;
let shieldActive = false;
let teleportCount = 0;
let canTeleport = true;
let isShrunk = false; 
let isSwapping = false; 

// --- ENTITIES ---
let player;
let obstacles = [];
let particles = [];
let upgradeOptions = [];

// --- CLASSES ---

class Player {
    constructor() {
        this.baseW = 30;
        this.baseH = 30;
        this.w = this.baseW;
        this.h = this.baseH;
        this.x = 100;
        this.y = 300;
        this.vy = 0;
        this.vx = 0; 
        this.onGround = false;
        this.jumpCount = 0;
        this.color = '#0ff';
        this.dashActive = false;
        this.isDiving = false;
    }

    update() {
        // SHRINK LOGIC
        if (skills.shrink > 0 && keys.KeyR) {
            let maxShrink = skills.shrink === 2 ? 0.4 : 0.6; 
            this.w = this.baseW * maxShrink;
            this.h = this.baseH * maxShrink;
            this.color = '#ff0'; 
            isShrunk = true;
        } else {
            this.w = this.baseW;
            this.h = this.baseH;
            this.color = '#0ff';
            isShrunk = false;
        }

        // GRAVITY & PHYSICS
        if (!this.dashActive) {
            // Float Skill
            if (skills.float > 0 && keys.KeyX && this.vy > 0) {
                let limit = skills.float === 2 ? 120 : 60;
                if (floatTimer < limit) {
                    this.vy = 0.5 * (GRAVITY > 0 ? 1 : -1); 
                    floatTimer++;
                    createParticle(this.x, this.y + this.h, '#fff');
                } else {
                    this.vy += GRAVITY;
                }
            } 
            // Dive Skill
            else if (skills.dive > 0 && keys.KeyC && !this.onGround) {
                this.vy = (GRAVITY > 0 ? 20 : -20);
                this.isDiving = true;
                createParticle(this.x + this.w/2, this.y, '#f00');
            }
            else {
                this.vy += GRAVITY;
                this.isDiving = false;
            }
        }

        this.x += this.vx; 
        this.y += this.vy;

        // DASH LOGIC
        if (this.dashActive) {
            dashTimer--;
            if (dashTimer <= 0) {
                this.dashActive = false;
                this.vy = 0;
                this.vx = 0; 
            }
        }
        
        // Horizontal clamping and snap back
        if (this.x < 100) this.x = 100;
        if (this.x > 250) this.x = 250; 
        if (!this.dashActive && this.x > 100) this.x -= 2; 

        // Floor / Ceiling Collision
        let floorY = GRAVITY > 0 ? canvas.height - 20 - this.h : 20;
        let ceilingY = GRAVITY > 0 ? 20 : canvas.height - 20 - this.h;

        if ((GRAVITY > 0 && this.y + this.h > canvas.height - 20) || (GRAVITY < 0 && this.y < 20)) {
            this.y = floorY;
            this.vy = 0;
            this.onGround = true;
            this.jumpCount = 0;
            floatTimer = 0;
            teleportCount = 0; 
        } else {
            this.onGround = false;
        }
    }

    jump() {
        let maxJumps = 1;
        if (skills.doubleJump === 1) maxJumps = 2;
        if (skills.doubleJump === 2) maxJumps = 3;

        if (this.jumpCount < maxJumps) {
            this.vy = (GRAVITY > 0 ? JUMP_FORCE : -JUMP_FORCE);
            this.jumpCount++;
            this.onGround = false;
            for(let i=0; i<5; i++) createParticle(this.x + this.w/2, this.y + this.h, '#0ff');
        }
    }

    dash() {
        if (skills.dash > 0 && canDash && !this.dashActive) {
            this.dashActive = true;
            canDash = false;
            
            let duration = skills.dash === 2 ? 15 : 10;
            let speed = skills.dash === 2 ? 30 : 20; 
            dashTimer = duration;
            
            this.vy = 0; 
            this.vx = speed; 
            
            for(let i=0; i<15; i++) createParticle(this.x, this.y + this.h/2, '#0ff');
            
            setTimeout(() => { canDash = true; }, skills.dash === 2 ? 600 : 1000);
        }
    }

    teleport() {
        if (skills.teleport > 0 && canTeleport) {
            let maxTeleports = skills.teleport === 2 ? 2 : 1;
            
            if (teleportCount < maxTeleports) {
                let dist = skills.teleport === 2 ? 200 : 120;
                
                this.x += dist; 
                teleportCount++;

                for(let i=0; i<30; i++) createParticle(this.x - dist, this.y + this.h/2, '#f00');
                for(let i=0; i<30; i++) createParticle(this.x, this.y + this.h/2, '#f00');

                if (skills.teleport === 1 || teleportCount === maxTeleports) {
                    canTeleport = false;
                    setTimeout(() => {
                        canTeleport = true;
                        teleportCount = 0;
                    }, 1500);
                }
            }
        }
    }

    gravitySwap() {
        if (skills.gravitySwap > 0 && !isSwapping) {
            GRAVITY *= -1;
            isSwapping = true;
            let cd = skills.gravitySwap === 2 ? 600 : 1800;
            for(let i=0; i<50; i++) createParticle(canvas.width/2, canvas.height/2, '#0ff');
            setTimeout(() => { isSwapping = false; }, cd);
        }
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        
        if (shieldActive) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(this.x - 5, this.y - 5, this.w + 10, this.h + 10);
        }

        ctx.fillRect(this.x, this.y, this.w, this.h);
        
        ctx.fillStyle = '#000';
        let eyeY = GRAVITY > 0 ? this.y + 5 : this.y + this.h - 13;
        ctx.fillRect(this.x + 18 * (this.w/this.baseW), eyeY, 8 * (this.w/this.baseW), 8 * (this.h/this.baseH));
        
        ctx.restore();
    }
}

class Obstacle {
    constructor(x, type, h1 = 0, h2 = 0) {
        this.x = x;
        this.w = 30 + Math.random() * 20;
        this.h = 30 + Math.random() * 40;
        this.type = type; 
        this.markedForDeletion = false;
        this.rotation = 0; 
        this.companion = null; 

        // Base positioning logic
        if (GRAVITY > 0) {
            this.y = canvas.height - 20 - this.h;
            if (type === 1) this.y -= 50; 
        } else {
            this.y = 20;
            if (type === 1) this.y += 50;
        }

        // --- TYPE SPECIFIC INIT ---
        
        // Type 2: Double Gap (Hard)
        if (type === 2) { 
             let gapSize = player.baseH * 3.5; // Increased gap size for fairness
             let floorH = h1 || Math.random() * (canvas.height - 40 - gapSize - 100) + 50;
             let ceilH = h2 || canvas.height - 40 - gapSize - floorH;
             this.w = 40;
             
             this.y = canvas.height - 20 - floorH;
             this.h = floorH;

             this.companion = {
                x: this.x, y: 20, w: this.w, h: ceilH,
                draw: function() {
                    ctx.save(); ctx.shadowBlur=10; ctx.shadowColor='#f0f'; ctx.fillStyle='#f0f';
                    ctx.fillRect(this.x, this.y, this.w, this.h); ctx.restore();
                },
                update: function(s) { this.x -= s; }
             };
        }

        // Type 3: Long Horizontal
        if (type === 3) this.w = 150 + difficultyLevel * 20; 

        // Type 4: Tower
        if (type === 4) this.h = canvas.height * 0.5 + Math.random() * 100;

        // Type 6: Oscillator (Vertical Mover)
        if (type === 6) {
            this.baseY = this.y - 50; 
            this.oscSpeed = 0.05 + Math.random() * 0.05;
        }

        // Type 7: Pulser
        if (type === 7) {
            this.baseW = this.w;
            this.baseH = this.h;
            this.baseX = this.x;
            this.baseY = this.y;
            this.pulseSpeed = 0.1;
        }

        // Type 8: Meteor (Diagonal Fall)
        if (type === 8) {
            this.y = -100; // Start above screen
            this.vy = 4 + Math.random() * 2;
        }

        // Type 9: The Gate (Wall with hole)
        if (type === 9) {
            this.w = 40;
            let holeSize = player.baseH * 3;
            let holeY = 50 + Math.random() * (canvas.height - 100 - holeSize);
            
            // Bottom part
            this.y = holeY + holeSize;
            this.h = canvas.height - 20 - this.y;
            
            // Top part (Companion)
            this.companion = {
                x: this.x, y: 20, w: this.w, h: holeY - 20,
                draw: function() {
                    ctx.save(); ctx.shadowBlur=10; ctx.shadowColor='#f0f'; ctx.fillStyle='#f0f';
                    ctx.fillRect(this.x, this.y, this.w, this.h); ctx.restore();
                },
                update: function(s) { this.x -= s; }
            };
        }

        // Type 10: Crusher (Closing gap)
        if (type === 10) {
            this.w = 60;
            this.gap = 200;
            this.y = canvas.height - 20 - 50; // Start low
            this.h = 50;
            this.closingSpeed = 0.5;

            this.companion = {
                x: this.x, y: 20, w: this.w, h: 50, // Start high
                draw: function() {
                    ctx.save(); ctx.shadowBlur=10; ctx.shadowColor='#f0f'; ctx.fillStyle='#f0f';
                    ctx.fillRect(this.x, this.y, this.w, this.h); ctx.restore();
                },
                update: function(s) { this.x -= s; }
            };
        }

        // General Shift logic
        if (type !== 6 && type !== 8) {
            this.baseY = this.y;
            this.offset = Math.random() * 100;
        }
    }

    update() {
        this.x -= GAME_SPEED;
        if (this.x + this.w < -100) this.markedForDeletion = true;

        if (this.companion) {
            this.companion.update(GAME_SPEED);
            if (this.companion.x + this.companion.w < -100) this.markedForDeletion = true;
        }

        // Type 5: Spinner Rotation
        if (this.type === 5) this.rotation += 0.1 * (GAME_SPEED / INITIAL_SPEED);

        // Type 6: Oscillator
        if (this.type === 6) {
            this.y = this.baseY + Math.sin(frame * this.oscSpeed) * 80;
        }

        // Type 7: Pulser
        if (this.type === 7) {
            let scale = 1 + Math.sin(frame * this.pulseSpeed) * 0.3;
            this.w = this.baseW * scale;
            this.h = this.baseH * scale;
            // Adjust position to keep it grounded/centered roughly
            if (GRAVITY > 0) this.y = canvas.height - 20 - this.h;
            else this.y = 20;
        }

        // Type 8: Meteor
        if (this.type === 8) {
            this.y += this.vy;
            // Floor collision
            if (this.y + this.h > canvas.height - 20) {
                this.y = canvas.height - 20 - this.h;
                this.vy = 0; // Stop falling
            }
        }

        // Type 10: Crusher
        if (this.type === 10 && this.companion) {
            // Grow towards center
            if (this.h < canvas.height/2 - 40) this.h += this.closingSpeed;
            if (this.companion.h < canvas.height/2 - 40) this.companion.h += this.closingSpeed;
            
            // Re-calc y for bottom part
            this.y = canvas.height - 20 - this.h;
        }

        // Shifting Hazard Logic
        let isShifting = activeHazards.some(h => h.type === 'shift');
        if (isShifting && this.type !== 6 && this.type !== 8 && this.type !== 10) {
            this.y = this.baseY + Math.sin((frame + this.offset) * 0.05) * 40;
        }
    }

    draw() {
        if (this.companion) this.companion.draw();

        if (this.type === 5) { // Spinner
             ctx.save();
             ctx.translate(this.x + this.w/2, this.y + this.h/2);
             ctx.rotate(this.rotation);
             ctx.shadowBlur = 10;
             ctx.shadowColor = '#f0f';
             ctx.fillStyle = '#f0f';
             ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
             ctx.restore();
        } else {
             ctx.save();
             ctx.shadowBlur = 10;
             ctx.shadowColor = '#f0f';
             ctx.fillStyle = '#f0f';
             ctx.fillRect(this.x, this.y, this.w, this.h);
             ctx.restore();
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = (Math.random() - 0.5) * 5;
        this.life = 30;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1;
    }
}

function createParticle(x, y, color) {
    particles.push(new Particle(x, y, color));
}

// --- GAME LOGIC ---

function triggerHazard() {
    if (activeHazards.length === 0) {
        timeSinceHazard = 0;
        hazardMaxTime = 600 + difficultyLevel * 60;
    }
    
    const basePool = ['gravity', 'fast', 'dense', 'shift'];
    const advancedPool = ['chaos', 'flicker'];
    let pool = difficultyLevel > 3 ? basePool.concat(advancedPool) : basePool;
    
    let selectedHazard = pool[Math.floor(Math.random() * pool.length)];
    let hazardCount = difficultyLevel > 5 ? 2 : 1;
    
    for (let i = 0; i < hazardCount; i++) {
        let currentPool = pool.filter(h => !activeHazards.some(ah => ah.type === h));
        if (currentPool.length === 0) break;
        selectedHazard = currentPool[Math.floor(Math.random() * currentPool.length)];

        activeHazards.push({
            type: selectedHazard, 
            timer: hazardMaxTime,
            id: Math.random()
        });
    }
}

function endHazard(hazardId) {
    let hazardIndex = activeHazards.findIndex(h => h.id === hazardId);
    if (hazardIndex !== -1) {
        let type = activeHazards[hazardIndex].type;
        activeHazards.splice(hazardIndex, 1);
        
        if (type === 'gravity' || type === 'chaos') {
            if (!activeHazards.some(h => h.type === 'gravity' || h.type === 'chaos')) {
                 GRAVITY = BASE_GRAVITY;
            }
        }
        if (type === 'fast') {
            if (!activeHazards.some(h => h.type === 'fast')) {
                 GAME_SPEED = currentBaseSpeed;
            }
        }

        if (activeHazards.length === 0) {
            endAllHazards();
        }
    }
}

function endAllHazards() {
    activeHazards = [];
    GRAVITY = BASE_GRAVITY;
    GAME_SPEED = currentBaseSpeed; 
    messageTimer = 120; 
    generateUpgrades();
    isPaused = true;
}

function generateUpgrades() {
    upgradeOptions = [];
    const pool = [
        { id: 'doubleJump', txt: "Extra Jump" },
        { id: 'dash', txt: "Mid-air Dash" },
        { id: 'float', txt: "Float (Hold X)" },
        { id: 'dive', txt: "Dive (Hold C)" },
        { id: 'shield', txt: "Shield (One-time)" },
        { id: 'slowTime', txt: "Slow Time (V)" },
        { id: 'teleport', txt: "Teleport (T)" },
        { id: 'shrink', txt: "Shrink (R)" },
        { id: 'gravitySwap', txt: "Grav Swap (G)" }
    ];

    while(upgradeOptions.length < 3) {
        let r = pool[Math.floor(Math.random() * pool.length)];
        if (!upgradeOptions.includes(r)) {
            if (r.id === 'shield' && skills.shield) continue; 
            if (typeof skills[r.id] === 'number' && skills[r.id] >= 2) continue;
            upgradeOptions.push(r);
        }
    }
}

function selectUpgrade(index) {
    let choice = upgradeOptions[index];
    if (!choice) return;

    if (choice.id === 'shield') {
        skills.shield = true;
        shieldActive = true;
    } else {
        skills[choice.id]++;
    }

    isPaused = false;
    timeSinceHazard = 0;
    upgradeOptions = [];
}

function resetGame() {
    score = 0;
    difficultyLevel = 0;
    currentBaseSpeed = INITIAL_SPEED;
    isGameOver = false;
    isPaused = false;
    frame = 0;
    timeSinceHazard = 0;
    activeHazards = [];
    GRAVITY = BASE_GRAVITY;
    
    // Reset Skills
    skills.doubleJump = 0; skills.dash = 0; skills.float = 0; 
    skills.dive = 0; skills.shield = false; skills.slowTime = 0;
    skills.teleport = 0; skills.shrink = 0; skills.gravitySwap = 0;
    shieldActive = false;
    teleportCount = 0;

    player = new Player();
    obstacles = [];
    particles = [];
}

// --- VISUALS ---

function drawHazardVisuals() {
    ctx.save();
    
    let isShifting = activeHazards.some(h => h.type === 'shift');
    let isFlickering = activeHazards.some(h => h.type === 'flicker');

    if (activeHazards.some(h => h.type === 'gravity' || h.type === 'chaos')) {
        ctx.fillStyle = 'rgba(100, 0, 255, 0.1)';
        ctx.font = '50px Arial';
        let offset = (frame * 2) % 100;
        for (let i = 0; i < canvas.width; i += 100) {
            for (let j = 0; j < canvas.height; j += 100) {
                ctx.fillText('â†‘', i, j - offset + 100);
            }
        }
    }
    
    if (activeHazards.some(h => h.type === 'fast')) {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
        ctx.lineWidth = 2;
        for(let i=0; i<15; i++) {
            let y = Math.random() * canvas.height;
            let len = Math.random() * 200 + 50;
            let x = Math.random() * canvas.width;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - len, y);
            ctx.stroke();
        }
    }

    if (activeHazards.some(h => h.type === 'dense')) {
        ctx.fillStyle = `rgba(255, 0, 0, ${Math.abs(Math.sin(frame/10)) * 0.3})`;
        ctx.fillRect(0, 0, canvas.width, 20); // Ceiling
        ctx.fillRect(0, canvas.height-20, canvas.width, 20); // Floor
    }

    if (isShifting) {
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 40) {
            ctx.moveTo(x, 0);
            for(let y = 0; y < canvas.height; y += 10) {
                 ctx.lineTo(x + Math.sin((frame + y) * 0.05)*10, y);
            }
        }
        ctx.stroke();
    }
    
    if (isFlickering) {
        ctx.fillStyle = `rgba(0,0,0, ${0.4 + Math.abs(Math.sin(frame/50)) * 0.2})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    ctx.restore();
}

function getHazardLabel(type) {
    if (type === 'gravity') return "GRAVITY REVERSE";
    if (type === 'fast') return "SPEED SURGE";
    if (type === 'dense') return "OBSTACLE SWARM";
    if (type === 'shift') return "REALITY SHIFT";
    if (type === 'chaos') return "GRAVITY CHAOS";
    if (type === 'flicker') return "VISIBILITY FLICKER";
    return "";
}

function drawUI() {
    ctx.font = '24px Courier New';
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#0f0';
    ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${score}`, 20, 40);
    ctx.shadowBlur = 0;

    ctx.font = '12px Courier New';
    ctx.fillStyle = '#888';
    ctx.fillText("SPACE: Jump | Z: Dash | X: Float | C: Dive", 20, 65);
    ctx.fillText("R: Shrink | T: Teleport | G: Grav Swap | V: Slow Time", 20, 85);

    if (activeHazards.length > 0) {
        ctx.font = 'bold 30px Courier New';
        ctx.fillStyle = '#f0f';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#f0f';
        ctx.textAlign = 'center';

        let labelText = activeHazards.map(h => getHazardLabel(h.type)).join(" & ");
        
        if (Math.floor(frame / 20) % 2 === 0) {
            ctx.fillText("HAZARD: " + labelText, canvas.width/2, 50);
        }
        ctx.shadowBlur = 0;

        let barWidth = 400;
        let firstHazard = activeHazards[0];
        let pct = firstHazard.timer / hazardMaxTime;
        ctx.fillStyle = '#333';
        ctx.fillRect(canvas.width/2 - barWidth/2, 70, barWidth, 10);
        ctx.fillStyle = '#f0f';
        ctx.fillRect(canvas.width/2 - barWidth/2, 70, barWidth * pct, 10);
        
    } else if (messageTimer > 0) {
        ctx.font = '30px Courier New';
        ctx.fillStyle = '#0f0';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#0f0';
        ctx.textAlign = 'center';
        ctx.fillText("HAZARD SURVIVED!", canvas.width/2, 50);
        messageTimer--;
    }
}

// --- MAIN LOOP ---

function animate() {
    if (isGameOver) return;
    if (isPaused) {
        drawUpgradeMenu();
        return;
    }

    let newLevel = Math.floor(score / 500);
    if (newLevel > difficultyLevel) {
        difficultyLevel = newLevel;
        currentBaseSpeed += 0.5; 
    }
    
    let isFast = activeHazards.some(h => h.type === 'fast');
    let isChaos = activeHazards.some(h => h.type === 'chaos');
    let isGravReverse = activeHazards.some(h => h.type === 'gravity');
    
    GAME_SPEED = currentBaseSpeed;
    if (isFast) GAME_SPEED = currentBaseSpeed + 4; 
    if (isChaos && frame % 30 === 0) GRAVITY *= -1; 
    if (isGravReverse && !isChaos) GRAVITY = -BASE_GRAVITY; 

    if (skills.slowTime > 0 && keys.KeyV && slowTimer > 0) {
        GAME_SPEED = 2;
        slowTimer--;
    } else {
        if (slowTimer < (skills.slowTime * 100)) slowTimer++; 
    }
    
    activeHazards.forEach((hazard, index) => {
        hazard.timer--;
        if (hazard.timer <= 0) {
            endHazard(hazard.id);
        }
    });

    if (activeHazards.length === 0) {
        timeSinceHazard++;
        let triggerTime = difficultyLevel > 5 ? 400 : 500;
        if (timeSinceHazard > triggerTime) triggerHazard(); 
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawHazardVisuals();

    frame++;
    score++;
    
    // Spawning Logic Rebalanced
    let baseSpawnRate = 90 - (difficultyLevel * 5);
    if (baseSpawnRate < 40) baseSpawnRate = 40;
    
    let isDense = activeHazards.some(h => h.type === 'dense');
    let spawnRate = isDense ? Math.floor(baseSpawnRate / 2) : baseSpawnRate;
    
    if (frame % spawnRate === 0) {
        let r = Math.random();
        let obsType = 0; 

        // Level 0-2: Basic
        if (difficultyLevel < 2) {
             obsType = r < 0.3 ? 1 : 0; 
        } 
        // Level 2-5: Add Oscillator (6), Meteor (8)
        else if (difficultyLevel < 5) {
             obsType = r < 0.2 ? 6 : (r < 0.4 ? 8 : (r < 0.6 ? 1 : 0));
        } 
        // Level 5-8: Add Pulser (7), Spinner (5), Tower (4), Long (3)
        else if (difficultyLevel < 8) {
             if (r < 0.15) obsType = 7;
             else if (r < 0.3) obsType = 5;
             else if (r < 0.45) obsType = 4;
             else if (r < 0.6) obsType = 3;
             else obsType = 0;
        } 
        // Level 8+: Unlock Double Gap (2), The Gate (9), Crusher (10)
        else {
             if (r < 0.1) obsType = 2; // Double Gap (Rare)
             else if (r < 0.2) obsType = 9; // The Gate
             else if (r < 0.3) obsType = 10; // Crusher
             else if (r < 0.4) obsType = 8; // Meteor
             else if (r < 0.5) obsType = 6; // Oscillator
             else obsType = 0;
        }
        
        obstacles.push(new Obstacle(canvas.width, obsType));
    }

    player.update();
    player.draw();

    obstacles.forEach((obs, index) => {
        obs.update();
        obs.draw();

        let companionCollided = false;
        if (obs.companion) {
             if (player.x < obs.companion.x + obs.companion.w && player.x + player.w > obs.companion.x &&
                 player.y < obs.companion.y + obs.companion.h && player.y + player.h > obs.companion.y) {
                    companionCollided = true;
             }
             if (obs.companion.x + obs.companion.w < -100) obs.markedForDeletion = true;
        }

        let mainCollided = (
            player.x < obs.x + obs.w && player.x + player.w > obs.x &&
            player.y < obs.y + obs.h && player.y + player.h > obs.y
        );

        if (mainCollided || companionCollided) {
            let collidedObs = mainCollided ? obs : obs.companion;

            if (skills.dive === 2 && player.isDiving) {
                obs.markedForDeletion = true;
                if (obs.companion) obs.companion.markedForDeletion = true;
                for(let i=0; i<10; i++) createParticle(collidedObs.x, collidedObs.y, '#ff0');
                score += 100;
            } 
            else if (shieldActive) {
                shieldActive = false;
                skills.shield = false;
                obs.markedForDeletion = true;
                if (obs.companion) obs.companion.markedForDeletion = true;
                for(let i=0; i<20; i++) createParticle(player.x, player.y, '#fff');
            }
            else {
                isGameOver = true;
            }
        }
    });

    obstacles = obstacles.filter(obs => !obs.markedForDeletion);

    particles.forEach((p, i) => {
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(i, 1);
    });

    ctx.fillStyle = '#333';
    ctx.fillRect(0, canvas.height-20, canvas.width, 20);
    ctx.fillRect(0, 0, canvas.width, 20);

    drawUI();

    if (isGameOver) drawGameOver();
}

function drawStartMenu() {
    if (menuDrawn) return; 

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#0ff';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#0ff';
    ctx.font = '60px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText("NEON DASH", canvas.width/2, 180);
    
    let btnX = canvas.width/2;
    let btnY = 300;
    let btnW = 200;
    let btnH = 50;

    ctx.strokeStyle = '#f0f';
    ctx.lineWidth = 3;
    ctx.strokeRect(btnX - btnW/2, btnY - btnH/2, btnW, btnH);
    
    ctx.fillStyle = '#f0f';
    ctx.font = '24px Courier New';
    ctx.fillText("START RUN", btnX, btnY + 8);
    ctx.shadowBlur = 0;
    
    ctx.fillStyle = '#888';
    ctx.font = '12px Courier New';
    ctx.textAlign = 'left';
    ctx.fillText("Controls:", 20, 380);
    ctx.fillText("SPACE: Jump | Z: Dash | X: Float | C: Dive", 20, 400);
    ctx.fillText("R: Shrink | T: Teleport | G: Grav Swap | V: Slow Time", 20, 420);
    menuDrawn = true;
}

function drawUpgradeMenu() {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#fff';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#fff';
    ctx.font = '30px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText("HAZARD CLEARED", canvas.width/2, 80);
    ctx.font = '20px Courier New';
    ctx.fillText("Select an Augmentation", canvas.width/2, 110);
    ctx.shadowBlur = 0;

    upgradeOptions.forEach((opt, i) => {
        let x = canvas.width/2 - 250 + (i * 170);
        let y = 160;
        
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, 150, 200);
        
        ctx.fillStyle = '#0ff';
        ctx.font = '16px Courier New';
        
        let words = opt.txt.split(" ");
        words.forEach((w, line) => {
            ctx.fillText(w, x + 75, y + 80 + (line*20));
        });

        let lvl = skills[opt.id];
        let txt = "";
        if (opt.id === 'shield') {
            txt = "ONE USE";
        } else {
             txt = lvl === 0 ? "UNLOCK" : (lvl === 1 ? "UPGRADE" : "MAXED");
        }
        ctx.fillStyle = '#ff0';
        ctx.fillText(txt, x + 75, y + 40);
    });
}

function drawGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.fillStyle = '#f00';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#f00';
    ctx.font = '60px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText("CRASHED", canvas.width/2, 180);
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = '30px Courier New';
    ctx.fillText(`FINAL SCORE: ${score}`, canvas.width/2, 240);
    
    ctx.font = '20px Courier New';
    ctx.fillStyle = '#aaa';
    ctx.fillText("Click to Reboot System", canvas.width/2, 300);
}

// --- INPUT LISTENERS ---
window.addEventListener('keydown', e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
    if (isGameOver || isPaused || !isStarted) return;
    
    if (e.code === 'Space') player.jump();
    if (e.code === 'KeyZ') player.dash();
    if (e.code === 'KeyT') player.teleport();
    if (e.code === 'KeyG') player.gravitySwap();
});

window.addEventListener('keyup', e => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    
    if (!isStarted) {
        let btnX = canvas.width/2;
        let btnY = 300;
        let btnW = 200;
        let btnH = 50;
        
        if (mx >= btnX - btnW/2 && mx <= btnX + btnW/2 && 
            my >= btnY - btnH/2 && my <= btnY + btnH/2) {
            isStarted = true;
            menuDrawn = false;
            resetGame();
        }
        return;
    }

    if (isGameOver) {
        isStarted = false; 
        menuDrawn = false;
        return;
    }
    
    if (isPaused) {
        upgradeOptions.forEach((opt, i) => {
            let x = canvas.width/2 - 250 + (i * 170);
            let y = 160;
            if (mx >= x && mx <= x + 150 && my >= y && my <= y + 200) {
                selectUpgrade(i);
            }
        });
    }
});

function gameLoop() {
    if (!isStarted) {
        drawStartMenu();
    } else {
        animate();
    }
    requestAnimationFrame(gameLoop);
}

gameLoop();

</script>
</body>
</html>
